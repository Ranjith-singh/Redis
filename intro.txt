redis is basically a in memory storage structure/database for storing data in primary memory/ram
    to keep the data in hot
redis allows 110000 writes/sec and 80000 reads/sec
the data is kept in persistent way and maintains data atomicity
redis support different dataTypes like str, int, char, list, arr etc
you can install redis through cmd or package manager
    cmd: sudo apt install redis-server
    run cmd: redis-server
redis String:
    initialize/reinitialize: set [varname] [value]
    read: get [varname]
    substring: getrange [varname] [range]: both included
    strlen: strlen [varname]
    delete: expire [varname] [timeInSec]: optional
        you can directly set expiration time during initialization
redis Int:
    incr: increment
    incrBy: increment incrBy
get all keys: keys *
remove all keys: flushall
redis List:
    lpush [varname] [value]: top/left push to list
    rpush [varname] [value]: bottom/right push to list
    lrem/rrem [varname] [count] [value]
    lindex [varname] [index]: get element at that index
    linsert [varname] [index] [value]
    lrange [varname] [start] [end]
    lset [varname] [index] [value]
    lpushX/rpushX: check if list exists then push
    sort [varname] [pattern]
redis set:
    stores only unique elements
    sadd [varname] [values]...
    srem [varname] [values]...
    smembers [varname]: all elements
    scard [varname]: length
    sismember [varname] [value]: checks for member
    sdiff [var1] [var2]: var1-var2
    sinter [varname]...
    sunion [varname]...
    s[diff/inter/union]store [destination] [varname]... : stores the returned values
redis sortedSets:
    zadd [varname] [score] [value]..
    zrange [varname] [min] [max] withscore: optional
    zcard [varname]
    zcount [varname] [min] [max]
    zrevrange [varname]
    z[rem/remrangebyscore/remrangebyrank] [varname]
redis hyperloglog:
    storing complex values such as ip, emails etc
    pfadd [varname] [values]...
    pfcount [varname]...
    pfmerge [varname]...
redis hashMap:
    h[set/mset] [varname] [keys] [values]...
    h[get/mget] [varname] [keys] [values]...
    hkeys [varname]
    hvals [varname]
    hgetall [varname]
    hincrby [varname] [key] [value]
    hdel [varname] [key]
    hlen [varname]
    hstrlen [varname] [key]
    hsetnx [varname] [key] [value]: check for key and add
redis transactions:
    cause redis provides atomicity we can group multiple cmds into a single transaction using multi and exec
    you can also discard a transaction if no longer needed
redis scripts:
    you can use the redis inBuild scripts to execute redis cmds using redis.call()
    you can even build your own scripts on top of redis scripts and return values
    use eval cmd to execute the scripts and load to store the scripts
redis pubsub:
    you can create publisher and subscriber to a topic so they can send and receive events
    a client can publish and subscribe to multiple topics
    you can also publish/subscribe to a channel based on patterns
redis connection and security:
    a single redis server can have multiple clients
    you need host and port of the server to connect to it
    a single server can have multiple database
        but in reality all of them are stored in a single rdb or Aof
    you can also add authentication to your server using password
        so when a new client needs to execute cmds he needs to provide password
redis GeoSpatial:
    you can provide longitude(x-axis) and latitude(y-axis) for particular location and fetch them
    the redis views global as spherical shaped 3d obj
    you can get the pos based on the ip and also get displacement b/w the locations
    also find a locations within certain range from a location
redis benchmark:
    you can find the benchmark of your redis-server based on different params
    you can change the number of requests to serve on, size of data and number to clients to serve on.
